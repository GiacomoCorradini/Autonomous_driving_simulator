//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
//
// pass_primitivej0.cpp
//
// Code generation for function 'pass_primitivej0'
//

// Include files
#include "pass_primitivej0.h"
#include "a_opt_mex_data.h"
#include "evalPrimitiveCoeffs.h"
#include "rt_nonfinite.h"
#include "mwmathutil.h"

// Variable Definitions
static emlrtRSInfo t_emlrtRSI{
    4,                  // lineNo
    "pass_primitivej0", // fcnName
    "/home/giacomo/University/Autonomous_driving_simulator/basic_agent_st/"
    "matlab/pass_primitivej0.m" // pathName
};

static emlrtRSInfo u_emlrtRSI{
    5,                  // lineNo
    "pass_primitivej0", // fcnName
    "/home/giacomo/University/Autonomous_driving_simulator/basic_agent_st/"
    "matlab/pass_primitivej0.m" // pathName
};

static emlrtRSInfo v_emlrtRSI{
    8,                  // lineNo
    "pass_primitivej0", // fcnName
    "/home/giacomo/University/Autonomous_driving_simulator/basic_agent_st/"
    "matlab/pass_primitivej0.m" // pathName
};

static emlrtRSInfo w_emlrtRSI{
    10,                 // lineNo
    "pass_primitivej0", // fcnName
    "/home/giacomo/University/Autonomous_driving_simulator/basic_agent_st/"
    "matlab/pass_primitivej0.m" // pathName
};

static emlrtRSInfo x_emlrtRSI{
    13,                 // lineNo
    "pass_primitivej0", // fcnName
    "/home/giacomo/University/Autonomous_driving_simulator/basic_agent_st/"
    "matlab/pass_primitivej0.m" // pathName
};

static emlrtRSInfo bb_emlrtRSI{
    14,               // lineNo
    "finalOptTimej0", // fcnName
    "/home/giacomo/University/Autonomous_driving_simulator/basic_agent_st/"
    "matlab/finalOptTimej0.m" // pathName
};

// Function Definitions
void pass_primitivej0(const emlrtStack *sp, real_T v0, real_T a0, real_T sf,
                      real_T v_min, real_T v_max, real_T m[6], real_T *tfj0,
                      real_T *vfj0)
{
  emlrtStack b_st;
  emlrtStack st;
  real_T T_bar_idx_0;
  real_T t2;
  real_T t8;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  covrtLogFcn(&emlrtCoverageInstance, 6, 0);
  covrtLogBasicBlock(&emlrtCoverageInstance, 6, 0);
  //  Passing primitive algorithm with j0 = 0
  st.site = &t_emlrtRSI;
  covrtLogFcn(&emlrtCoverageInstance, 7, 0);
  covrtLogBasicBlock(&emlrtCoverageInstance, 7, 0);
  // finalOptTimej0
  //     Tvf_j0 = finalOptTimej0(V0,A0,SF)
  //     This function was generated by the Symbolic Math Toolbox version 9.2.
  //     12-Dec-2022 17:49:45
  t2 = v0 * 5.0;
  t8 = a0 * sf * 8.0 + t2 * v0;
  b_st.site = &bb_emlrtRSI;
  if (t8 < 0.0) {
    emlrtErrorWithMessageIdR2018a(
        &b_st, &emlrtRTEI, "Coder:toolbox:ElFunDomainError",
        "Coder:toolbox:ElFunDomainError", 3, 4, 4, "sqrt");
  }
  t8 = muDoubleScalarSqrt(t8);
  t8 *= 2.23606797749979;
  T_bar_idx_0 = sf * 10.0 / (t2 + t8);
  *tfj0 = sf * 10.0 / (t2 - t8);
  st.site = &u_emlrtRSI;
  covrtLogFcn(&emlrtCoverageInstance, 8, 0);
  covrtLogBasicBlock(&emlrtCoverageInstance, 8, 0);
  // finalOptVelj0
  //     VF_J0 = finalOptVelj0(V0,A0,SF,T)
  //     This function was generated by the Symbolic Math Toolbox version 9.2.
  //     12-Dec-2022 17:49:44
  *vfj0 = ((sf * -20.0 + T_bar_idx_0 * v0 * 12.0) +
           T_bar_idx_0 * T_bar_idx_0 * a0 * 3.0) *
          -0.125 / T_bar_idx_0;
  if (covrtLogCond(&emlrtCoverageInstance, 6, 0, 0, v_min < *vfj0) &&
      covrtLogCond(&emlrtCoverageInstance, 6, 0, 1, *vfj0 < v_max)) {
    covrtLogMcdc(&emlrtCoverageInstance, 6, 0, 0, true);
    covrtLogIf(&emlrtCoverageInstance, 6, 0, 0, true);
    covrtLogBasicBlock(&emlrtCoverageInstance, 6, 1);
    *tfj0 = T_bar_idx_0;
    st.site = &v_emlrtRSI;
    evalPrimitiveCoeffs(v0, a0, sf, *vfj0, T_bar_idx_0, m);
  } else {
    covrtLogMcdc(&emlrtCoverageInstance, 6, 0, 0, false);
    covrtLogIf(&emlrtCoverageInstance, 6, 0, 0, false);
    covrtLogBasicBlock(&emlrtCoverageInstance, 6, 2);
    st.site = &w_emlrtRSI;
    covrtLogFcn(&emlrtCoverageInstance, 8, 0);
    covrtLogBasicBlock(&emlrtCoverageInstance, 8, 0);
    // finalOptVelj0
    //     VF_J0 = finalOptVelj0(V0,A0,SF,T)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:44
    *vfj0 = ((sf * -20.0 + *tfj0 * v0 * 12.0) + *tfj0 * *tfj0 * a0 * 3.0) *
            -0.125 / *tfj0;
    if (covrtLogCond(&emlrtCoverageInstance, 6, 0, 2, v_min < *vfj0) &&
        covrtLogCond(&emlrtCoverageInstance, 6, 0, 3, *vfj0 < v_max)) {
      covrtLogMcdc(&emlrtCoverageInstance, 6, 0, 1, true);
      covrtLogIf(&emlrtCoverageInstance, 6, 0, 1, true);
      covrtLogBasicBlock(&emlrtCoverageInstance, 6, 3);
      st.site = &x_emlrtRSI;
      evalPrimitiveCoeffs(v0, a0, sf, *vfj0, *tfj0, m);
    } else {
      covrtLogMcdc(&emlrtCoverageInstance, 6, 0, 1, false);
      covrtLogIf(&emlrtCoverageInstance, 6, 0, 1, false);
      covrtLogBasicBlock(&emlrtCoverageInstance, 6, 4);
      for (int32_T i{0}; i < 6; i++) {
        m[i] = 0.0;
      }
      *tfj0 = 0.0;
      *vfj0 = 0.0;
    }
  }
}

// End of code generation (pass_primitivej0.cpp)
