//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
//
// primitives.cpp
//
// Code generation for function 'primitives'
//

// Include files
#include "primitives.h"
#include "rt_nonfinite.h"
#include <cmath>

// Function Declarations
static double rt_powd_snf(double u0, double u1);

// Function Definitions
static double rt_powd_snf(double u0, double u1)
{
  double y;
  if (std::isnan(u0) || std::isnan(u1)) {
    y = rtNaN;
  } else {
    double d;
    double d1;
    d = std::abs(u0);
    d1 = std::abs(u1);
    if (std::isinf(u1)) {
      if (d == 1.0) {
        y = 1.0;
      } else if (d > 1.0) {
        if (u1 > 0.0) {
          y = rtInf;
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = rtInf;
      }
    } else if (d1 == 0.0) {
      y = 1.0;
    } else if (d1 == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = std::sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > std::floor(u1))) {
      y = rtNaN;
    } else {
      y = std::pow(u0, u1);
    }
  }
  return y;
}

double a_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  // A_OPT
  //     OUT1 = A_OPT(t,V0,A0,SF,VF,AF,T)
  //     This function was generated by the Symbolic Math Toolbox version 9.2.
  //     12-Dec-2022 17:49:18
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return ((a0 - 1.0 / rt_powd_snf(T, 5.0) * rt_powd_snf(t, 3.0) *
                    ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
                     t4_tmp) *
                    10.0) +
          t * t / (t2 * t2) *
              ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
               b_out1_tmp * 14.0) *
              6.0) -
         1.0 / rt_powd_snf(T, 3.0) * t *
             ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) + b_out1_tmp * 8.0) *
             3.0;
}

void pass_primitive(double a0, double v0, double sf, double *v_min,
                    double *v_max, double t_min, double t_max, double m1[6],
                    double m2[6], double *t1, double *t2)
{
  double tv_min_tmp;
  double v_bar;
  //  Passing primitive algorithm
  if (a0 >= 0.0) {
    // finalOptTime
    //     OUT1 = finalOptTime(V0,A0,SF,VF)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:36
    v_bar = a0 * sf * 60.0;
    tv_min_tmp = v0 * v0 * 49.0;
    *t2 = sf * 30.0 /
          ((v0 * 7.0 + *v_min * 8.0) +
           std::sqrt(((v_bar + v0 * *v_min * 112.0) + tv_min_tmp) +
                     *v_min * *v_min * 64.0));
    // finalOptTime
    //     OUT1 = finalOptTime(V0,A0,SF,VF)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:36
    *t1 = sf * 30.0 /
          ((v0 * 7.0 + *v_max * 8.0) +
           std::sqrt(((v_bar + v0 * *v_max * 112.0) + tv_min_tmp) +
                     *v_max * *v_max * 64.0));
  } else {
    // finalOptTimeVel
    //     OUT1 = finalOptTimeVel(A0,SF)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:36
    *t2 = -(3.872983346207417 * std::sqrt(-a0 * sf)) / a0;
    // finalOptVel
    //     VF_BAR = finalOptVel(V0,A0,SF,T)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:36
    v_bar = ((sf * -15.0 + *t2 * v0 * 7.0) + *t2 * *t2 * a0) * -0.125 / *t2;
    if ((v_bar < *v_min) && (*v_min < *v_max)) {
      // finalOptTime
      //     OUT1 = finalOptTime(V0,A0,SF,VF)
      //     This function was generated by the Symbolic Math Toolbox
      //     version 9.2. 12-Dec-2022 17:49:36
      *t2 =
          sf * 30.0 /
          ((v0 * 7.0 + *v_min * 8.0) +
           std::sqrt(((a0 * sf * 60.0 + v0 * *v_min * 112.0) + v0 * v0 * 49.0) +
                     *v_min * *v_min * 64.0));
      // finalOptTime
      //     OUT1 = finalOptTime(V0,A0,SF,VF)
      //     This function was generated by the Symbolic Math Toolbox
      //     version 9.2. 12-Dec-2022 17:49:36
      *t1 =
          sf * 30.0 /
          ((v0 * 7.0 + *v_max * 8.0) +
           std::sqrt(((a0 * sf * 60.0 + v0 * *v_max * 112.0) + v0 * v0 * 49.0) +
                     *v_max * *v_max * 64.0));
    } else if ((*v_min < v_bar) && (v_bar < *v_max)) {
      // finalOptTime
      //     OUT1 = finalOptTime(V0,A0,SF,VF)
      //     This function was generated by the Symbolic Math Toolbox
      //     version 9.2. 12-Dec-2022 17:49:36
      *t1 =
          sf * 30.0 /
          ((v0 * 7.0 + *v_max * 8.0) +
           std::sqrt(((a0 * sf * 60.0 + v0 * *v_max * 112.0) + v0 * v0 * 49.0) +
                     *v_max * *v_max * 64.0));
    } else {
      *t2 = 0.0;
      *t1 = 0.0;
    }
  }
  if ((!(t_min == 0.0)) || (!(t_max == 0.0))) {
    *t1 = std::fmax(*t1, t_min);
    *t2 = std::fmin(*t2, t_max);
  }
  if ((*t1 > 0.0) && (*t1 <= *t2)) {
    double b_t4_tmp;
    double d;
    double d1;
    double m1_tmp;
    double t3;
    double t4;
    double t4_tmp;
    // finalOptVel
    //     VF_BAR = finalOptVel(V0,A0,SF,T)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:36
    d = *t2 * *t2;
    d1 = *t2 * v0;
    t4_tmp = d * a0;
    *v_min = ((sf * -15.0 + d1 * 7.0) + t4_tmp) * -0.125 / *t2;
    // finalOptVel
    //     VF_BAR = finalOptVel(V0,A0,SF,T)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:36
    v_bar = *t1 * *t1;
    tv_min_tmp = *t1 * v0;
    b_t4_tmp = v_bar * a0;
    *v_max = ((sf * -15.0 + tv_min_tmp * 7.0) + b_t4_tmp) * -0.125 / *t1;
    // evalPrimitiveCoeffs
    //     M = evalPrimitiveCoeffs(V0,A0,SF,VF,AF,T)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:18
    t3 = 0.0 * v_bar;
    t4 = b_t4_tmp * 3.0;
    m1[0] = 0.0;
    m1[1] = v0;
    m1[2] = a0;
    m1_tmp = *t1 * *v_max;
    m1[3] = 1.0 / rt_powd_snf(*t1, 3.0) *
            ((((sf * -20.0 + t4) - t3) + tv_min_tmp * 12.0) + m1_tmp * 8.0) *
            -3.0;
    m1[4] =
        1.0 / (v_bar * v_bar) *
        ((((sf * -30.0 - t3 * 2.0) + t4) + tv_min_tmp * 16.0) + m1_tmp * 14.0) *
        12.0;
    m1[5] =
        1.0 / rt_powd_snf(*t1, 5.0) *
        ((((sf * -12.0 - t3) + tv_min_tmp * 6.0) + m1_tmp * 6.0) + b_t4_tmp) *
        -60.0;
    // evalPrimitiveCoeffs
    //     M = evalPrimitiveCoeffs(V0,A0,SF,VF,AF,T)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:18
    t3 = 0.0 * d;
    t4 = t4_tmp * 3.0;
    m2[0] = 0.0;
    m2[1] = v0;
    m2[2] = a0;
    v_bar = *t2 * *v_min;
    m2[3] = 1.0 / rt_powd_snf(*t2, 3.0) *
            ((((sf * -20.0 + t4) - t3) + d1 * 12.0) + v_bar * 8.0) * -3.0;
    m2[4] = 1.0 / (d * d) *
            ((((sf * -30.0 - t3 * 2.0) + t4) + d1 * 16.0) + v_bar * 14.0) *
            12.0;
    m2[5] = 1.0 / rt_powd_snf(*t2, 5.0) *
            ((((sf * -12.0 - t3) + d1 * 6.0) + v_bar * 6.0) + t4_tmp) * -60.0;
  } else {
    for (int i{0}; i < 6; i++) {
      m1[i] = 0.0;
      m2[i] = 0.0;
    }
    *t1 = 0.0;
    *t2 = 0.0;
    *v_min = 0.0;
    *v_max = 0.0;
  }
}

void pass_primitivej0(double v0, double a0, double sf, double v_min,
                      double v_max, double m[6], double *tfj0, double *vfj0)
{
  double T_bar_idx_0;
  double b_vfj0_tmp;
  double t2;
  double t9;
  double vfj0_tmp;
  double vfj0_tmp_tmp;
  //  Passing primitive algorithm with j0 = 0
  // finalOptTimej0
  //     Tvf_j0 = finalOptTimej0(V0,A0,SF)
  //     This function was generated by the Symbolic Math Toolbox version 9.2.
  //     12-Dec-2022 17:49:45
  t2 = v0 * 5.0;
  t9 = 2.23606797749979 * std::sqrt(a0 * sf * 8.0 + t2 * v0);
  T_bar_idx_0 = sf * 10.0 / (t2 + t9);
  *tfj0 = sf * 10.0 / (t2 - t9);
  // finalOptVelj0
  //     VF_J0 = finalOptVelj0(V0,A0,SF,T)
  //     This function was generated by the Symbolic Math Toolbox version 9.2.
  //     12-Dec-2022 17:49:44
  t2 = T_bar_idx_0 * T_bar_idx_0;
  t9 = T_bar_idx_0 * v0;
  vfj0_tmp = t9 * 12.0;
  vfj0_tmp_tmp = t2 * a0;
  b_vfj0_tmp = vfj0_tmp_tmp * 3.0;
  *vfj0 = ((sf * -20.0 + vfj0_tmp) + b_vfj0_tmp) * -0.125 / T_bar_idx_0;
  if ((v_min < *vfj0) && (*vfj0 < v_max)) {
    double m_tmp;
    double t3;
    *tfj0 = T_bar_idx_0;
    // evalPrimitiveCoeffs
    //     M = evalPrimitiveCoeffs(V0,A0,SF,VF,AF,T)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:18
    t3 = 0.0 * t2;
    m[0] = 0.0;
    m[1] = v0;
    m[2] = a0;
    m_tmp = T_bar_idx_0 * *vfj0;
    m[3] = 1.0 / rt_powd_snf(T_bar_idx_0, 3.0) *
           ((((sf * -20.0 + b_vfj0_tmp) - t3) + vfj0_tmp) + m_tmp * 8.0) * -3.0;
    m[4] =
        1.0 / (t2 * t2) *
        ((((sf * -30.0 - t3 * 2.0) + b_vfj0_tmp) + t9 * 16.0) + m_tmp * 14.0) *
        12.0;
    m[5] = 1.0 / rt_powd_snf(T_bar_idx_0, 5.0) *
           ((((sf * -12.0 - t3) + t9 * 6.0) + m_tmp * 6.0) + vfj0_tmp_tmp) *
           -60.0;
  } else {
    // finalOptVelj0
    //     VF_J0 = finalOptVelj0(V0,A0,SF,T)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:44
    t2 = *tfj0 * *tfj0;
    t9 = *tfj0 * v0;
    vfj0_tmp = t9 * 12.0;
    vfj0_tmp_tmp = t2 * a0;
    b_vfj0_tmp = vfj0_tmp_tmp * 3.0;
    *vfj0 = ((sf * -20.0 + vfj0_tmp) + b_vfj0_tmp) * -0.125 / *tfj0;
    if ((v_min < *vfj0) && (*vfj0 < v_max)) {
      double m_tmp;
      double t3;
      // evalPrimitiveCoeffs
      //     M = evalPrimitiveCoeffs(V0,A0,SF,VF,AF,T)
      //     This function was generated by the Symbolic Math Toolbox
      //     version 9.2. 12-Dec-2022 17:49:18
      t3 = 0.0 * t2;
      m[0] = 0.0;
      m[1] = v0;
      m[2] = a0;
      m_tmp = *tfj0 * *vfj0;
      m[3] = 1.0 / rt_powd_snf(*tfj0, 3.0) *
             ((((sf * -20.0 + b_vfj0_tmp) - t3) + vfj0_tmp) + m_tmp * 8.0) *
             -3.0;
      m[4] = 1.0 / (t2 * t2) *
             ((((sf * -30.0 - t3 * 2.0) + b_vfj0_tmp) + t9 * 16.0) +
              m_tmp * 14.0) *
             12.0;
      m[5] = 1.0 / rt_powd_snf(*tfj0, 5.0) *
             ((((sf * -12.0 - t3) + t9 * 6.0) + m_tmp * 6.0) + vfj0_tmp_tmp) *
             -60.0;
    } else {
      for (int i{0}; i < 6; i++) {
        m[i] = 0.0;
      }
      *tfj0 = 0.0;
      *vfj0 = 0.0;
    }
  }
}

void primitives_initialize()
{
}

void primitives_terminate()
{
}

void stop_primitive(double v0, double a0, double sf, double m[6], double *tf,
                    double *smax)
{
  //  Stopping primitive algorithm
  if ((v0 <= 0.0) || (sf == 0.0)) {
    *tf = 0.0;
    *smax = 0.0;
    for (int i{0}; i < 6; i++) {
      m[i] = 0.0;
    }
  } else {
    double m_tmp;
    double t2;
    double t3;
    double t4;
    double t4_tmp;
    t2 = 4.0 * (v0 * v0);
    if (t2 + 5.0 * a0 * sf < 0.0) {
      *smax = -(t2 / (5.0 * a0));
      *tf = 10.0 * *smax / (2.0 * v0);
    } else {
      *smax = sf;
      // finalOptTimeStop
      //     OUT1 = finalOptTimeStop(V0,A0,SF)
      //     This function was generated by the Symbolic Math Toolbox
      //     version 9.2. 12-Dec-2022 17:49:35
      *tf = sf * 10.0 / (v0 * 2.0 + std::sqrt(a0 * sf * 5.0 + t2));
    }
    // evalPrimitiveCoeffs
    //     M = evalPrimitiveCoeffs(V0,A0,SF,VF,AF,T)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:18
    t2 = *tf * *tf;
    t3 = 0.0 * t2;
    t4_tmp = a0 * t2;
    t4 = t4_tmp * 3.0;
    m[0] = 0.0;
    m[1] = v0;
    m[2] = a0;
    m_tmp = *tf * v0;
    m[3] = 1.0 / rt_powd_snf(*tf, 3.0) *
           ((((*smax * -20.0 + t4) - t3) + m_tmp * 12.0) + *tf * 0.0 * 8.0) *
           -3.0;
    m[4] = 1.0 / (t2 * t2) *
           ((((*smax * -30.0 - t3 * 2.0) + t4) + m_tmp * 16.0) +
            *tf * 0.0 * 14.0) *
           12.0;
    m[5] = 1.0 / rt_powd_snf(*tf, 5.0) *
           ((((*smax * -12.0 - t3) + m_tmp * 6.0) + *tf * 0.0 * 6.0) + t4_tmp) *
           -60.0;
  }
}

void stop_primitivej0(double v0, double a0, double m[6], double *T,
                      double *smax)
{
  //  Stopping primitive algorithm with j0 = 0
  if ((v0 > 0.0) && (a0 < 0.0)) {
    double m_tmp;
    double t2;
    double t3;
    double t4;
    double t4_tmp;
    // finalOptTimeStopj0
    //     OUT1 = finalOptTimeStopj0(V0,A0)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:44
    *T = v0 * -2.0 / a0;
    // finalOptPosj0
    //     SF_J0 = finalOptPosj0(V0,A0,T)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:44
    *smax = *T * (v0 * 4.0 + *T * a0) * 0.15;
    // evalPrimitiveCoeffs
    //     M = evalPrimitiveCoeffs(V0,A0,SF,VF,AF,T)
    //     This function was generated by the Symbolic Math Toolbox version 9.2.
    //     12-Dec-2022 17:49:18
    t2 = *T * *T;
    t3 = 0.0 * t2;
    t4_tmp = a0 * t2;
    t4 = t4_tmp * 3.0;
    m[0] = 0.0;
    m[1] = v0;
    m[2] = a0;
    m_tmp = *T * v0;
    m[3] = 1.0 / rt_powd_snf(*T, 3.0) *
           ((((*smax * -20.0 + t4) - t3) + m_tmp * 12.0) + *T * 0.0 * 8.0) *
           -3.0;
    m[4] =
        1.0 / (t2 * t2) *
        ((((*smax * -30.0 - t3 * 2.0) + t4) + m_tmp * 16.0) + *T * 0.0 * 14.0) *
        12.0;
    m[5] = 1.0 / rt_powd_snf(*T, 5.0) *
           ((((*smax * -12.0 - t3) + m_tmp * 6.0) + *T * 0.0 * 6.0) + t4_tmp) *
           -60.0;
  } else {
    *T = 0.0;
    *smax = 0.0;
    for (int i{0}; i < 6; i++) {
      m[i] = 0.0;
    }
  }
}

double v_opt(double t, double v0, double a0, double sf, double vf, double af,
             double T)
{
  double b_out1_tmp;
  double out1_tmp;
  double t2;
  double t3;
  double t4;
  double t4_tmp;
  // V_OPT
  //     OUT1 = V_OPT(t,V0,A0,SF,VF,AF,T)
  //     This function was generated by the Symbolic Math Toolbox version 9.2.
  //     12-Dec-2022 17:49:18
  t2 = T * T;
  t3 = af * t2;
  t4_tmp = a0 * t2;
  t4 = t4_tmp * 3.0;
  out1_tmp = T * v0;
  b_out1_tmp = T * vf;
  return (((v0 + a0 * t) -
           1.0 / rt_powd_snf(T, 5.0) * rt_powd_snf(t, 4.0) *
               ((((sf * -12.0 - t3) + out1_tmp * 6.0) + b_out1_tmp * 6.0) +
                t4_tmp) *
               2.5) -
          1.0 / rt_powd_snf(T, 3.0) * (t * t) *
              ((((sf * -20.0 + t4) - t3) + out1_tmp * 12.0) +
               b_out1_tmp * 8.0) *
              1.5) +
         rt_powd_snf(t, 3.0) / (t2 * t2) *
             ((((sf * -30.0 - t3 * 2.0) + t4) + out1_tmp * 16.0) +
              b_out1_tmp * 14.0) *
             2.0;
}

// End of code generation (primitives.cpp)
